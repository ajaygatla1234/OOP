package com.gl.java8;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Streams_Demo_4 {

	public static void main(String[] args) {

		System.out.println("--------------int Stream(Passing direct elements to Stream)--------------"); //we can also do it for other data types(float,double,char,String)

		/**
		 * Note:
		 * 
		 * Operations on a stream can be performed only once. once a stream is operated upon, it cannot be reused.
		 * Attempting to perform another operation on the same stream will result in an IllegalStateException.
		 * To avoid this, consider storing the intermediate result of one stream operation into a new stream variable
		 * or collect the result into a data structure before performing additional operations.
		 */

		//Set of elements converted into stream
		Stream<Integer> intStream=Stream.of(100,200,300,400,500);								


		/*As per the Note, try executing each operation individually while commenting out the other operations.*/


		/*Ways of displaying Streams Directly: */

		//		intStream.forEach(System.out::println);  										// using non-static method reference for printing

		//or
		//		intStream.forEach(element -> System.out.print(element+" ")); 					// using Lambda Expression (lambda expression iteration)

																
		/* 
		 * System.out.print(intStream); 	
		 * 
		 * It prints the address. Directly printing the stream object doesn't provide the elements because the stream itself doesn't store the elements; it processes them on-demand when terminal operations are applied.
		 * When working with streams, you need to apply a terminal operation like forEach, collect, or toArray. This triggers the processing of the stream, allowing you to access its elements for printing or other operations.
		 * These printed values are not memory addresses but provide information about the stream's identity in terms of its class type and hash code.
		 * 
		 * Key Points:
		 * Memory Address: Java does not expose actual memory addresses of objects. The output you see is the result of the toString() method. Even for printing objects also it is not the actual address, it is just used to identify the object.
		 * Hash Code: The hash code is a unique identifier for the object instance within the JVM and is generated by the hashCode() method. It's not the actual memory address but serves as a proxy for identifying the object.
		 * 
		 * */
							
		
		/*Ways of converting Streams into List & Displaying*/

				List<Integer> intStreamList1=intStream.collect(Collectors.toList());  			// Collect the elements of myStream1 into a List using Collectors.toList(). The toList() method, defined in the Collectors class, specifies that the collection returned will be an ArrayList by default.
				System.out.println("Converting Stream to list (collect) : "+intStreamList1);  	//Since the toString() of ArrayList is overridden to print the list. The list is Printed Directly

		//or
		//		List<Integer> intStreamList2=intStream.toList();    							// Requires JDK version 16 or above to use stringStream1.toList(); otherwise, Compiler cannot detect it.
		//		System.out.println("Converting Stream to list (toList) : "+intStreamList2);

		//or
		//		Stream<Integer> tempStream=intStream.map(x->x);   								//Creating a new stream by applying a mapping operation to the original stream
		//		List<Integer> intStreamList3=tempStream.collect(Collectors.toList()); 			//Here, we collect the elements of the stream into a list
		//		System.out.println(intStreamList3);

		//or
		//		String stream=intStream.map(Object::toString)  									//If you want to concatenate the elements into a single string, you can use the collect method with Collectors.joining
		//				.collect(Collectors.joining(","));				
		//		System.out.println(stream);
				
		//or
		/* Creating an ArrayList<Integer> by using a Stream to generate elements and collecting them into a List
		   Step 1: Stream.of(1, 2, 3, 4, 5) creates a Stream of Integer elements
		   Step 2: collect(Collectors.toList()) collects the elements of the Stream into a List
		   Step 3: new ArrayList<>(...) initializes a new ArrayList with the collected List
		 */
				ArrayList<Integer> obj = new ArrayList<>(Stream.of(1, 2, 3, 4, 5).collect(Collectors.toList()));
				System.out.println(obj);


		//		System.out.println(intStream.count());  										// Printing the count of elements in the original stream


		/*Ways of converting Lists into Streams & Displaying*/
				
				Stream<Integer> listStream=intStreamList1.stream();
				listStream.forEach(element->System.out.print(element+" "));
				
				
				

		System.out.println("\n\n--------------Array Stream (Passing Arrays to the Stream)--------------"); 

		/*Ways of Converting Arrays to Stream*/

		/* Creating an IntStream from an array of primitive int using Arrays.stream*/
				int[] intArray1 = {1, 2, 3, 4, 5};
				IntStream intStream1 = Arrays.stream(intArray1);
				intStream1.forEach(System.out::print);
				System.out.println();

		//or
		/* Creating an IntStream directly from an anonymous array of primitive int using Arrays.stream*/
				IntStream intStream2=Arrays.stream( new int[] {1,2,3,4});
				intStream2.forEach(System.out::print);
				System.out.println();

		//or
		/*Creating a Stream from an array of Integer objects using Stream.of*/
				Integer[] intArray2= {1,2,3,4,5,6};
				Stream<Integer> intStream3=Stream.of(intArray2);
				intStream3.forEach(System.out::print);           
				System.out.println();

		//or
		/* Creating a Stream from an anonymous array of Integer objects using Stream.of*/
				Stream<Integer> integerArray=Stream.of(new Integer[] {1000,2000,3000,4000,5000});
				integerArray.forEach(element->System.out.print(element+" "));

		//or
		/*
		 	Not recommended: This creates a Stream<int[]> with one element (the entire array)

		 	int[] intArray1 = {100, 200, 300, 400, 500};
		    Stream<int[]> intStream1 = Stream.of(intArray1); 
		    intStream1.forEach(array -> System.out.println(Arrays.toString(array)));  This will print the entire array as a single element

			If you want to use Arrays, use it with IntStream intStream = Arrays.stream(intArray); as shown in above
		 */

				
				
		/*
		 	We can create specialized streams for int, long, and double using IntStream, LongStream & DoubleStream interfaces and then call Arrays.stream() for Conversion;
		 	But for float & char, we don't have such inbuilt specialized stream Interfaces. So we need to use Stream.of() for Conversion.
		 */

		Float[] floatArray= new Float[] {1f,2f,3f,4f,5f,6f};
		Stream<Float> floatStream=Stream.of(floatArray);
		floatStream.forEach(item->System.out.print(item+" "));   
		System.out.println();



		Character[] charArray= new Character[] {'a', 'b', 'c', 'd', 'e'};
		Stream<Character> charStream=Stream.of(charArray);
		charStream.forEach(item->System.out.print(item+" "));
		System.out.println();



		String[] stringArray = {"apple", "banana", "cherry", "date", "elderberry"};
		Stream<String> stringStream = Stream.of(stringArray);
		stringStream.forEach(item->System.out.print(item+" "));    
		System.out.println();


		/*Ways of Converting Streams to List*/

		/*we can use same processes as implemented in int Stream (Passing direct elements to Stream)
		  But excluding them, we have one more process specially for Arrays as given below. */

				List<Integer> list2=Arrays.asList(100,200,300,400,500);  				//It is used to convert an array of objects into a fixed-size List. 
				Stream<Integer> listAtream2=list2.stream();
				listAtream2.forEach(item->System.out.print(item+" "));

		//or
				Integer[] arr= new Integer[]{1,2,3,4,5};
				List<Integer> list3=Arrays.asList(arr); 								 //It is used to convert an array of objects into a fixed-size List. 
				Stream<Integer> listAtream3=list3.stream();
				listAtream3.forEach(item->System.out.print(item+" "));



		System.out.println("\n\n--------------ArrayList Stream--------------");

		/*Ways of Converting list to stream*/
		
		List<Integer> arraylist1=new ArrayList<Integer>();
		for(int i=50;i>0;i--) {
			arraylist1.add(i);
		}
		
		
		Stream<Integer> seqentialStream=arraylist1.stream();                       // Create a sequential Stream from the ArrayList
		List<Integer> seqentialList=seqentialStream.collect(Collectors.toList());  // Collect the elements of the sequential Stream into a List
		System.out.println("Sequantial Stream of ArrayList : "+seqentialList);

		Stream<Integer> parallelStream=arraylist1.parallelStream();					// Create a parallel Stream from the ArrayList
		List<Integer> parallelList=parallelStream.collect(Collectors.toList());		// Collect the elements of the parallel Stream into a List
		System.out.println("Parallel Stream of ArrayList : "+parallelList);
		
		
		
		System.out.println("\nAnonymous Stream Printing Numbers greater than 25 using Sequantial Stream List : ");
		// Create a anonymous sequential stream from the list, filter numbers greater than 25, and print each number
		seqentialList.stream()
					 .filter(num->num>25)                                           //Intermediate Operator
					 .forEach(element->System.out.print(element+" "));				//Terminal Operator

		
		System.out.println("\n\nAnonymous Stream Printing Numbers less than 25 using Prallel Stream List : ");
		// Create a anonymous parallel stream from the list, filter numbers less than 25, and print each number
		parallelList.stream()
					 .filter(num->num<25)                                           
					 .forEach(element->System.out.print(element+" "));	
		
		/*Ways for Sorting*/
		
		//Sorted using Stream's sorted() method
		System.out.println("\n\nSorted using Stream's sorted() method : ");
		Stream<Integer> sampleStream1=seqentialList.stream();    					//since we can use stream only once, so created another stream
		Stream<Integer> sortedStream1=sampleStream1.sorted();
		sortedStream1.forEach(element->System.out.print(element+" "));
		
		System.out.println("\n\nAnonymous Stream Sorted, Filtered and Printed : ");
		//Creating an anonymous Sequential stream, Sorting, filtering and Printing
		seqentialList.stream()
		  .sorted()
		  .filter(num->num%2==0)
		  .forEach(element->System.out.print(element+" "));
		
		//or
		//Sorted using Stream's sorted() & Converted into List
		Stream<Integer> sampleStream2=seqentialList.stream(); 
		List<Integer> sortedList = sampleStream2.sorted().collect(Collectors.toList()); 
		System.out.println("Sorted using Stream's sorted() & Converted into List :  "+sortedList);
		
		
		
		
		// Using List's sort method to sort without converting to Stream
		/*sort method in ArrayList has two overloaded methods, one takes Comparable and other takes Comparator as Arguments*/
		seqentialList.sort(Integer::compareTo); //or seqentialList.sort(Comparable::compareTo); sort takes Comparable as an argument and performs natural Ordering(ascending order) as per the Overridden compareTo() in Integer. 
		seqentialList.sort(Integer::compare);   //or seqentialList.sort(Comparator.naturalOrder());(naturalOrder is the default static method present in Comparator, so we can access through the interface name) sort takes Comparator as an argument and performs natural Ordering(ascending order) as per the Overridden compare() in Integer.
		seqentialList.sort(Comparator.reverseOrder());
		
		/*
		 * We use method references when working with functional interfaces or normal interfaces. Method references allow us to call overridden or static methods present in the child class. However, if we’re calling methods directly from the parent interface, we can do so using the interface name. we need to create object of it and use
		 * But In case of seqentialList.sort(Integer::compare); object creation is not required to call compare even though it is instance method.
		 * 
		 * Reason:
		 * The Comparator functional interface has a method compare(T o1, T o2).
		 * The Integer::compare method reference matches the signature of this abstract method, taking two Integer arguments and returning an int.
		 * Even though compare is an instance method, the method reference Integer::compare is evaluated in a static context.
		 * The compiler knows that it needs an implementation of Comparator<Integer>, and Integer::compare fits the bill.
		 * Behind the scenes, Java performs autoboxing and unboxing.
		 * When you use Integer::compare, it’s equivalent to calling Integer.compare(Integer o1, Integer o2).
		 * The compiler automatically converts int values to Integer objects (autoboxing) when invoking the method.
		 * 
		 * 
		 * seqentialList.sort(Comparator::naturalOrder); we cannot use like this because, naturalOrder() is static method with Implementation present within Comparator interface, so we call it using its name directly.
		 * 
		 * */
		
		
		// or 
		Collections.sort(seqentialList);   //Internally, it may convert the list into an array to perform the sorting operations efficiently.
		System.out.println("\n\nSorted using List's sort() method: \n" + seqentialList);
		
		Collections.sort(seqentialList, Comparator.reverseOrder());
		System.out.println("\n\nReverse Sorted using List's sort() method: \n" + seqentialList);
		
		
		
		System.out.println("\n\n--------------String Stream--------------");
		
		
		List<String> stringList=new ArrayList<String>();
		
		stringList.add("Dave");
		stringList.add("Raj");
		stringList.add("Kiran");
		stringList.add("Suman");
		stringList.add("Emanuel");
		stringList.add("Amar");
		
		System.out.println("\nString to Uppercase String : \n");
		stringList.stream().map(name->name.toUpperCase()).forEach(System.out::println);
		
		
		
	}

}
